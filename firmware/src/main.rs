#![no_std]
#![no_main]

use core::any::Any;
use core::borrow::BorrowMut;
use core::sync::atomic::AtomicU32;
use defmt::*;
use embassy_executor::Spawner;
use embassy_stm32::exti::{AnyChannel, Channel, ExtiInput};
use embassy_stm32::gpio::{AnyPin, Level, Output, Pin, Pull, Speed};
use embassy_stm32::i2c::I2c;
use embassy_stm32::mode::Blocking;
use embassy_stm32::peripherals::I2C3;
use embassy_stm32::time::Hertz;
use embassy_sync::blocking_mutex::raw::{
    CriticalSectionRawMutex, NoopRawMutex, ThreadModeRawMutex,
};
use embassy_sync::channel::Channel as MessageChannel;
use embassy_sync::mutex::Mutex;
use embassy_sync::signal::Signal;
use embassy_time::{with_timeout, Duration, Ticker, Timer};
use firmware::bme280::bme280::Bme280I2c;
use {defmt_rtt as _, panic_probe as _};

use firmware::bme280::{BME280I2c, BME280Message, ControlSignal};

/// Global state
/// The countdown itself
static COUNTDOWN: AtomicU32 = AtomicU32::new(0);
/// The signal generated by a button press
static BUTTON_SIGNAL: Signal<CriticalSectionRawMutex, ButtonEvent> = Signal::new();
/// The state of the timer, which is only updated by the button press handler
static TIMER_STATE: Mutex<ThreadModeRawMutex, TimerState> = Mutex::new(TimerState::Reset);
/// Channels for communicating with the BME280 task
/// Data channel
static BME280_DATA_CHANNEL: MessageChannel<ThreadModeRawMutex, BME280Message, 2> =
    MessageChannel::new();
/// Control channel
static BME280_CONTROL_SIGNAL: Signal<CriticalSectionRawMutex, ControlSignal> = Signal::new();

#[derive(Debug, Format)]
enum TimerState {
    Running,
    Paused,
    Reset,
}

const POMO_DURATION_SECS: Duration = Duration::from_secs(25 * 60);
//const POMO_DURATION_SECS: Duration = Duration::from_secs(1 * 60);

#[embassy_executor::task]
async fn pomo_timer_task() {
    let mut ticker = Ticker::every(Duration::from_millis(1000));
    loop {
        ticker.next().await;
        let guard = TIMER_STATE.lock().await;
        match *guard {
            TimerState::Running => {
                if COUNTDOWN.load(core::sync::atomic::Ordering::Relaxed) > 0 {
                    COUNTDOWN.fetch_sub(1, core::sync::atomic::Ordering::Relaxed);
                }
                // TODO -- Maybe send a pubsub message with the current countdown time?
                // Not sure what the best method to convey current time is, but
                // pubsub might be good since multiple tasks may need to know.
            }
            TimerState::Paused => {}
            TimerState::Reset => {
                let duration = POMO_DURATION_SECS.as_secs();
                COUNTDOWN.store(duration as u32, core::sync::atomic::Ordering::Relaxed);
            }
        }
    }
}

enum ButtonEvent {
    ShortPress,
    LongPress,
}

#[embassy_executor::main]
async fn main(spawner: Spawner) {
    let p = embassy_stm32::init(Default::default());
    // TODO -- Get previous state of the system from non-volitile memory

    // Spawn background tasks
    spawner
        // Nucleo
        // .spawn(button_task(p.PC13.degrade(), p.EXTI13.degrade()))
        // Discovery
        .spawn(button_task(p.PA0.degrade(), p.EXTI0.degrade()))
        .unwrap();
    spawner.spawn(pomo_timer_task()).unwrap();
    // Nucleo
    // spawner.spawn(heartbeat_task(p.PA5.degrade())).unwrap();
    // Discovery
    spawner.spawn(heartbeat_task(p.PG13.degrade())).unwrap();

    let i2c = I2c::new_blocking(p.I2C3, p.PA8, p.PC9, Hertz(100_000), Default::default());
    spawner.spawn(bme280_task(i2c)).unwrap();

    // Main event loop
    loop {
        match BUTTON_SIGNAL.wait().await {
            ButtonEvent::ShortPress => {
                info!("Short Press Event");
                let mut guard = TIMER_STATE.lock().await;
                match *guard {
                    TimerState::Running => {
                        *guard = TimerState::Paused;
                    }
                    TimerState::Paused => {
                        *guard = TimerState::Running;
                    }
                    TimerState::Reset => {
                        *guard = TimerState::Running;
                    }
                }
            }
            ButtonEvent::LongPress => {
                info!("Long Press Event");
                let mut guard = TIMER_STATE.lock().await;
                match *guard {
                    TimerState::Running => {
                        *guard = TimerState::Reset;
                    }
                    TimerState::Paused => {
                        *guard = TimerState::Reset;
                    }
                    TimerState::Reset => {}
                }
            }
        };
    }
}

// Heartbeat task that toggles an LED every 1/2 second
#[embassy_executor::task]
async fn heartbeat_task(pin: AnyPin) {
    let mut led = Output::new(pin, Level::High, Speed::Low);
    // Use a ticker instead of a timer because it guarantees that
    // it will fire every interval instead of every interval plus the time it takes
    // to toggle the led.
    // https://github.com/embassy-rs/embassy/blob/main/embassy-time/src/timer.rs#L157
    let mut ticker = Ticker::every(Duration::from_millis(500));
    loop {
        led.toggle();
        debug!(
            "countdown: {}",
            COUNTDOWN.load(core::sync::atomic::Ordering::Relaxed)
        );
        ticker.next().await;
    }
}

// Task that just looks for long or short button presses
//
// Long press is hard-coded as >= 2 seconds
// Only one event signal will be sent after the long press no matter how long
// the button is held down.
#[embassy_executor::task]
async fn button_task(pin: AnyPin, exti_chan: AnyChannel) {
    let mut button = ExtiInput::new(pin, exti_chan, Pull::Down);
    // Do we need to debounce or is that done by Embassy?
    loop {
        // Nucleo
        // button.wait_for_falling_edge().await;
        // Discovery
        button.wait_for_rising_edge().await;
        debug!("FALLING EDGE");
        // Nucleo
        // match with_timeout(Duration::from_millis(2000), button.wait_for_rising_edge()).await {
        // Discovery
        match with_timeout(Duration::from_millis(2000), button.wait_for_falling_edge()).await {
            Ok(_) => {
                BUTTON_SIGNAL.signal(ButtonEvent::ShortPress);
            }
            Err(_) => {
                BUTTON_SIGNAL.signal(ButtonEvent::LongPress);
            }
        };
    }
}

#[embassy_executor::task]
async fn bme280_task(i2c: I2c<'static, Blocking>) {
    if let Ok(mut bme) = Bme280I2c::new(i2c).init().await {
        loop {
            if let Ok(temperature) = bme.read_temperature().await {
                info!("Temperature: {} C", temperature);
            } else {
                error!("Error reading temperature");
            }
            Timer::after(embassy_time::Duration::from_millis(1000)).await;
        }
    } else {
        error!("Error initializing BME280");
    };
}
